<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- sam9x60.qdoc -->
  <title>Getting started with SAM-BA on SAM9X60 devices | SAM-BA 3.3</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
</head>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="postheader" valign="center"> <a href="index.html">Home</a> &middot; </td></tr></table><li>Getting started with SAM-BA on SAM9X60 devices</li>
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#connecting-to-the-sam-ba-monitor">Connecting to the SAM-BA monitor</a></li>
<li class="level1"><a href="#predefined-boards-and-customer-board-designs">Predefined boards and customer board designs</a></li>
<li class="level1"><a href="#supported-applets">Supported applets</a></li>
<li class="level1"><a href="#otpc-emulation-mode">OTPC Emulation mode</a></li>
<li class="level1"><a href="#boot-configuration">Boot Configuration</a></li>
<li class="level2"><a href="#active-boot-configuration-packet">Active Boot Configuration packet</a></li>
<li class="level2"><a href="#rom-code-console">ROM Code console</a></li>
<li class="level2"><a href="#nvm-boot-sequence">NVM boot sequence</a></li>
<li class="level2"><a href="#programming-a-boot-configuration-packet">Programming a Boot Configuration packet</a></li>
<li class="level2"><a href="#reading-back-the-boot-configuration-packet">Reading back the Boot Configuration packet</a></li>
<li class="level2"><a href="#updating-the-boot-configuration-packet">Updating the Boot Configuration packet</a></li>
<li class="level2"><a href="#locking-the-boot-configuration-packet">Locking the Boot Configuration packet</a></li>
<li class="level2"><a href="#invalidating-the-boot-configuration-packet">Invalidating the <i>Boot Configuration</i> packet</a></li>
<li class="level1"><a href="#user-hardware-configuration">User Hardware Configuration</a></li>
<li class="level1"><a href="#secure-boot-configuration">Secure Boot Configuration</a></li>
<li class="level1"><a href="#programming-a-raw-nand-flash">Programming a raw NAND flash</a></li>
<li class="level1"><a href="#programming-a-qspi-nor-flash">Programming a QSPI NOR flash</a></li>
<li class="level1"><a href="#programming-a-spi-nor-flash">Programming a SPI NOR flash</a></li>
<li class="level1"><a href="#programming-a-sdcard-or-e-mmc-user-partition">Programming a SDCard or e.MMC user partition</a></li>
<li class="level1"><a href="#secure-boot-mode">Secure Boot Mode</a></li>
<li class="level2"><a href="#enabling-the-pairing-mode">Enabling the pairing mode</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Getting started with SAM-BA on SAM9X60 devices</h1>
<span class="subtitle"></span>
<!-- $$$sam9x60.html-description -->
<div class="descr"> <a name="details"></a>
<a name="connecting-to-the-sam-ba-monitor"></a>
<h2 id="connecting-to-the-sam-ba-monitor">Connecting to the SAM-BA monitor</h2>
<p>For USB connection, the host running <i>sam-ba</i> should be connected to the <b>USB device port</b> of the SAM9X60 board design. On SAM9X60-EK boards, this port is labeled <b>USBA (J7)</b>.</p>
<p><b>The USB device port must not be confused with other USB connectors such as VBUS_JLINK (J22)</b></p>
<a name="predefined-boards-and-customer-board-designs"></a>
<h2 id="predefined-boards-and-customer-board-designs">Predefined boards and customer board designs</h2>
<p>The <i>sam-ba</i> program comes with a predefined <i>sam9x60-ek</i> board that sets default values for different settings such as the <i>applet console</i> or memory controller <i>instances</i> and <i>iosets</i>.</p>
<p>This predefined board can be selected with the <i>-b sam9x60-ek</i> option on the <i>sam-ba</i> command line.</p>
<p>However the <i>-d sam9x60</i> option should be used instead on customer board designs not to load any default settings. Instead, additional parameters may be passed to the <a href="qml-samba-device-sam9x60-sam9x60config.html#serial-console-configuration">-d sam9x60:&lt;console_instance&gt;:&lt;console_ioset&gt; </a> option to select the <i>applet console</i>. The <i>applet console</i>, when enabled, is used by any applet to print its traces.</p>
<p>Also, default memory controller settings, if any, can be overridden too passing additionnal arguments to the <a href="applet.html#the-a-applet-option">-a &lt;applet&gt;</a> option for the applet mananing the memory controller.</p>
<a name="supported-applets"></a>
<h2 id="supported-applets">Supported applets</h2>
<p>The list of supported applets can be displayed with the following command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>a help
Known applets: bootconfig<span class="operator">,</span> lowlevel<span class="operator">,</span> extram<span class="operator">,</span> sdmmc<span class="operator">,</span> serialflash<span class="operator">,</span> qspiflash<span class="operator">,</span> nandflash<span class="operator">,</span> reset<span class="operator">,</span> readuniqueid</pre>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Applet</th><th >Short description</th><th >Examples</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="bootconfig-sam9x60.html">bootconfig</a></td><td >Manage boot configuration of the device, select boot media</td><td ><a href="sam9x60.html#programming-a-boot-configuration-packet">Programming a Boot Configuration packet</a></td></tr>
<tr valign="top" class="even"><td ><a href="extram.html">extram</a></td><td >Initialize the external RAM (not needed by any other applets)</td><td ></td></tr>
<tr valign="top" class="odd"><td ><a href="lowlevel.html">lowlevel</a></td><td >Setup the clock tree (only needed by the <i>extram</i> applet)</td></tr>
<tr valign="top" class="even"><td ><a href="nandflash.html">nandflash</a></td><td >Manage raw NAND flash memories connected to the EBI and driven by the SMC</td><td ><a href="sam9x60.html#programming-a-raw-nand-flash">Programming a raw NAND flash</a></td></tr>
<tr valign="top" class="odd"><td ><a href="pairingmode-sam9x60.html">pairingmode</a></td><td >Translate a bootstrap master image into a bootstrap paired image</td><td ></td></tr>
<tr valign="top" class="even"><td ><a href="qspiflash.html">qspiflash</a></td><td >Manage (Q)SPI NOR flash memories connected to the QSPI controller</td><td ><a href="sam9x60.html#programming-a-qspi-nor-flash">Programming a QSPI NOR flash</a></td></tr>
<tr valign="top" class="odd"><td ><a href="readuniqueid.html">readuniqueid</a></td><td >Read the device unique ID</td><td ></td></tr>
<tr valign="top" class="even"><td ><a href="reset.html">reset</a></td><td >Reset the target device</td></tr>
<tr valign="top" class="odd"><td ><a href="sdmmc.html">sdmmc</a></td><td >Manage e.MMC and SD Cards connected to some SDMMC instance</td><td ><a href="sam9x60.html#programming-a-sdcard-or-e-mmc-user-partition">Programming a SD Card or e.MMC</a></td></tr>
<tr valign="top" class="even"><td ><a href="serialflash.html">serialflash</a></td><td >Manage (Q)SPI NOR flash memories connected to some FLEXCOM SPI instance</td><td ><a href="sam9x60.html#programming-a-spi-nor-flash">Programming a SPI NOR flash</a></td></tr>
</table></div>
<a name="otpc-emulation-mode"></a>
<h2 id="otpc-emulation-mode">OTPC Emulation mode</h2>
<p>During developments and tests, we recommend the user to enable the OTPC emulation mode. Doing so, the OTPC controller replaces its OTP matrix by SRAM1 to store all user area packets, including the <a href="sam9x60.html#boot-configuration">Boot Configuration</a> packet, the <a href="sam9x60.html#secure-boot-configuration">Secure Boot Configuration</a> packet and the <a href="sam9x60.html#user-hardware-configuration">User Hardware Configuration</a> packet.</p>
<p>The <a href="bootconfig-sam9x60.html">bootconfig</a> applet provides the user with helper commands to manage the OTPC emulation mode.</p>
<p>As SRAM1 is powered by VDDBU, data are kept after reset, including user area packets of the OTPC emulation mode. However, those packets remain ignored by the ROM code unless the proper value is written into the BSCR register, for instance by executing the <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg:bscr:EMULATION_ENABLED</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a bootconfig <span class="operator">-</span>c writecfg:bscr:EMULATION_ENABLED</pre>
<p><b>Setting bit 0 (EMULATION_ENABLED) in the BSCR does not enable the OTPC emulation mode immediately</b>: it only tells the ROM code to enable the OTPC emulation mode on the next reset before fetching the <a href="sam9x60.html#boot-configuration">Boot Configuration</a> packet and any other user area packet.</p>
<p><b>WARNING: once any user area packet has been programmed into the OTP matrix, the emulation mode can never be enabled again. Be careful before writing a packet in the OTPC matrix !</b></p>
<p>To prevent the user from writing a packet into the OTP matrix by mistake, SAM-BA requires the user to append an explicit <i>emul</i> or <i>otp</i> suffix to the packet type telling whether this packet is stored into the OTP matrix or into SRAM1.</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Packet type / Stored in</th><th >SRAM1 (emulation mode)</th><th >OTP matrix</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="sam9x60.html#boot-configuration">Boot Configuration</a></td><td >bcp-emul</td><td >bcp-otp</td></tr>
<tr valign="top" class="even"><td ><a href="sam9x60.html#secure-boot-configuration">Secure Boot Configuration</a></td><td >sbcp-emul</td><td >sbcp-otp</td></tr>
<tr valign="top" class="odd"><td ><a href="sam9x60.html#user-hardware-configuration">User Hardware Configuration</a></td><td >uhcp-emul</td><td >uhcp-otp</td></tr>
</table></div>
<p>Before writing a first packet in emulation mode, SRAM1 must be reset to zero. This is the purpose of the <a href="bootconfig-sam9x60.html#the-resetemul-command">resetemul</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>c resetemul</pre>
<p>Once SRAM1 has been reset, the user should request the OTPC to scan again, hence refresh, packets in the user area by running a <a href="bootconfig-sam9x60.html#the-refreshcfg-command">refreshcfg:emul</a> command.</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c refreshcfg:emul</pre>
<p>Unlike the <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg:bscr:EMULATION_ENABLED</a>, the <a href="bootconfig-sam9x60.html#the-refreshcfg-command">refreshcfg:emul</a> command enables the OTPC emulation mode <b>immediately</b>, till the next power-on/reset or till disable again by the <a href="bootconfig-sam9x60.html#the-refreshcfg-command">refreshcfg:otp</a> command.</p>
<a name="boot-configuration"></a>
<h2 id="boot-configuration">Boot Configuration</h2>
<p>The ROM code of SAM9X60 devices is the 1st stage boot loader responsible for the system boot. Hence, the ROM code fetches the <a href="sam9x60.html#active-boot-configuration-packet">active Boot Configuration packet</a> from the OTPC in order to get boot settings such as the <a href="sam9x60.html#rom-code-console">ROM code console</a> and the <a href="sam9x60.html#nvm-boot-sequence">NVM boot sequence</a>.</p>
<a name="active-boot-configuration-packet"></a>
<h3 >Active Boot Configuration packet</h3>
<p>ROM code boot settings are stored in an OTPC packet of <i>Boot Configuration</i> type. Like any other OTPC packet, <i>Boot Configuration</i> packets can be read, programmed, locked or invalidated.</p>
<p>The <b>latest valid</b> <i>Boot Configuration</i> packet is the <b>active</b> <i>Boot Configuration</i> packet. That is to say the ROM code fetches its boot settings from this packet.</p>
<p>If no valid <i>Boot Configuration</i> packet is programmed in the OTPC, then the ROM code uses its <a href="sam9x60.html#rom-code-console">default console</a> and <a href="sam9x60.html#nvm-boot-sequence">default boot sequence</a> .</p>
<a name="rom-code-console"></a>
<h3 >ROM Code console</h3>
<p>The <i>Boot Configuration</i> packet tells the ROM code which RS-232 UART is to be used for the console. For instance, the &quot;RomBOOT&quot; string is always printed on power-on or reset on this console. Also, the ROM code console is used by SAM-BA monitors to communicate with the <i>sam-ba</i> program when USB is not available.</p>
<p>On SAM9X60, the default <i>ROM code console</i> is DBGU but it can be set to some FLEXCOMx USART. Please note that the <i>ROM code console</i> may be different from the <a href="sam9x60.html#predefined-boards-and-customer-board-designs">applet console</a></p>
<a name="nvm-boot-sequence"></a>
<h3 >NVM boot sequence</h3>
<p>The Non-Volatile Memory (NVM) boot sequence is the list of controllers managing external NVM where the ROM code tries to load the user application (or 2nd stage boot loader) from.</p>
<p>On SAM9X60, the default boot sequence is:</p>
<ol class="1" type="1"><li>SDMMC0 (e.MMC / SD Card)</li>
<li>SDMMC1 (e.MMC / SD Card)</li>
<li>QSPI (QSPI NOR flash)</li>
<li>FLEXCOM0 SPI (SPI NOR flash)</li>
<li>SMC (raw NAND flash)</li>
</ol>
<a name="programming-a-boot-configuration-packet"></a>
<h3 >Programming a Boot Configuration packet</h3>
<p>The user can program his first <i>Boot Configuration</i> packet with the <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg:bcp-emul / writecfg:bcp-otp</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:bcp<span class="operator">-</span>emul:QSPI0_IOSET1</pre>
<p>In this example, DBGU is implicitly chosen as the <i>ROM code console</i> and QSPI0 is the only boot media in the boot sequence.</p>
<p>If the user wants to try to boot from a NAND flash first, then from SDMMC1 then the <i>sam-ba</i> command will be:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:bcp<span class="operator">-</span>emul:NFC_IOSET1<span class="operator">,</span>SDMMC1_IOSET1</pre>
<p><b>The <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg</a> command fails on purpose to create a new packet if an active packet of the same type already exists <i>but cannot be updated</i>. This packet must be invalidated first by the <a href="bootconfig-sam9x60.html#the-invalidatecfg-command">invalidatecfg</a> command before creating a new valid packet.</b></p>
<a name="reading-back-the-boot-configuration-packet"></a>
<h3 >Reading back the Boot Configuration packet</h3>
<p>If an active <i>Boot Configuration</i> packet is available from the OTPC, this packet can be read-back with the <a href="bootconfig-sam9x60.html#the-readcfg-command">readcfg:bcp-emul / readcfg:bcp-otp</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c readcfg:bcp<span class="operator">-</span>emul</pre>
<p><b>If no active <i>Boot Configuration</i> packet is available from the OTPC, then this command reports an error. Especially, the default boot configuration used by the ROM code is <i>not</i> returned. Only the active <i>Boot Configuration</i> packet programmed in the OTPC can be returned.</b></p>
<a name="updating-the-boot-configuration-packet"></a>
<h3 >Updating the Boot Configuration packet</h3>
<p>Only 32-bit zero words can be updated in OTPC packet payloads. For instance, if the boot sequence is not full, the user can append another entry to the boot sequence. However, previous entries must be left unchanged. As an example, assuming the current boot sequence is &quot;NFC_IOSET1,SDMMC1_IOSET1&quot;, the user can still append a &quot;SDMMC0_IOSET1&quot; entry with the <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg:bcp-emul / writecfg:bcp-otp</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:bcp<span class="operator">-</span>emul:NFC_IOSET1<span class="operator">,</span>SDMMC1_IOSET1<span class="operator">,</span>SDMMC0_IOSET1</pre>
<p>The update or the creation of new <i>Boot Configuration</i> packet can be persistently disabled by setting the <i>BCPGDIS</i> bit of the <a href="sam9x60.html#user-hardware-configuration">User Hardware Configuration</a> packet.</p>
<a name="locking-the-boot-configuration-packet"></a>
<h3 >Locking the Boot Configuration packet</h3>
<p>Locking a packet discards any further modification of this packet, except its invalidation. Hence, once locked, a packet can no longer be updated. Locking the <i>Boot Configuration</i> packet is done by the <a href="bootconfig-sam9x60.html#the-lockcfg-command">lockcfg:bcp-emul / lockcfg:bcp-otp</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c lockcfg:bcp<span class="operator">-</span>emul
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:bcp<span class="operator">-</span>emul:NFC_IOSET1<span class="operator">,</span>SDMMC1_IOSET1<span class="operator">,</span>SDMMC0_IOSET1<span class="operator">,</span>FLEXCOM0_SPI_IOSET1</pre>
<p>The second command fails since the <i>Boot Configuration</i> packet has been locked by the first command.</p>
<p>Locking of <i>Boot Configuration</i> packets can be persistently disabled by setting the <i>BCLKDIS</i> bit of the <a href="sam9x60.html#user-hardware-configuration">User Hardware Configuration</a> packet.</p>
<a name="invalidating-the-boot-configuration-packet"></a>
<h3 >Invalidating the <i>Boot Configuration</i> packet</h3>
<p>The <i>Boot Configuration</i> packet can be tagged as invalid so it is ignored by the OTPC when it scans the user area, hence ignored by the ROM code on futher power-on/reset. This is achieved with the <a href="bootconfig-sam9x60.html#the-invalidatecfg-command">invalidatecfg:bcp-emul / invalidatecfg:bcp-otp</a> command</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c invalidatecfg:bcp<span class="operator">-</span>emul</pre>
<p>Packet invalidation cannot be reverted, however a new packet of the same type can be programmed with a new <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg:bcp-emul/ writecfg:otp-emul</a> command. In case of <i>Boot Configuration</i> packets, the latest packet that has been programmed but not invalidated yet is the active <i>Boot Configuration</i> packet.</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>ba sam9x60 <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:bcp<span class="operator">-</span>emul:NFC_IOSET1</pre>
<p>The invalidation of <i>Boot Configuration</i> packets can be persistently disabled by setting the <i>BCINVDIS</i> bit of the <a href="sam9x60.html#user-hardware-configuration">User Hardware Configuration</a> packet.</p>
<a name="user-hardware-configuration"></a>
<h2 id="user-hardware-configuration">User Hardware Configuration</h2>
<p>The <i>User Hardware Configuration</i> packet is designed for the user to persistently disable the JTAG port or some OTPC features and commands.</p>
<p>Like with the <i>Boot Configuration</i> packet, <i>sam-ba</i> provides commands to <a href="bootconfig-sam9x60.html#the-writecfg-command">create</a>, <a href="bootconfig-sam9x60.html#the-readcfg-command">read-back</a>, <a href="bootconfig-sam9x60.html#the-writecfg-command">update</a>, <a href="bootconfig-sam9x60.html#the-lockcfg-command">lock</a> and <a href="bootconfig-sam9x60.html#the-invalidatecfg-command">invalidate</a> the <i>User Hardware Configuration</i> packet.</p>
<p><b>When a <i>User Hardware Configuration</i> packet has been created or updated, the packet is not taken into account by the OTPC controller until the next power-on/reset or until a refresh operation has been triggered by the <a href="bootconfig-sam9x60.html#the-refreshcfg-command">refreshcfg</a> command</b>.</p>
<p>After each refresh, The payload of the active <i>User Hardware Configuration</i> packet is visible from <i>OTPC_UHC0R</i> and <i>OTPC_UHC1R</i> registers. Please refer to the OTPC section of the SAM9X60 datasheet for the exact description of those registers.</p>
<p><b>The <i>User Hardware Configuration</i> packet should be programmed at the end of the production to persistenly disable OTPC features such as programming, locking or invalidating given types of packet that may be used as breaches into the security of the customer device.</b></p>
<p>This is done with the <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg:uhcp-emul / writecfg:uhcp-otp</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:uhcp<span class="operator">-</span>emul:JTAGDIS<span class="operator">,</span>BCPGDIS<span class="operator">,</span>BCINVDIS<span class="operator">,</span>UHCPGDIS<span class="operator">,</span>UHCINVDIS</pre>
<a name="secure-boot-configuration"></a>
<h2 id="secure-boot-configuration">Secure Boot Configuration</h2>
<p>To enable the secure boot mode on SAM9X60 devices, an initial <i>Secure Boot Configuration</i> packet must be created with the <a href="bootconfig-sam9x60.html#the-writecfg-command">writecfg:sbcp-emul / writecfg:sbcp-otp</a> command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:sbcp<span class="operator">-</span>emul:SECURE_BOOT_ENABLED</pre>
<p>or shortly:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>a bootconfig <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>c writecfg:sbcp<span class="operator">-</span>emul:</pre>
<p><b>Don't forget the final colon (<i>:</i>) after <i>sbcp-emul</i> as the <i>writecfg</i> command expects 2 arguments; the 2nd argument being left to its default <i>SECURE_BOOT_ENABLED</i> value.</b></p>
<p>For further details on how to configure the secure boot mode, refer to <a href="sam9x60.html#secure-boot-mode">Secure Boot Mode</a>.</p>
<a name="programming-a-raw-nand-flash"></a>
<h2 id="programming-a-raw-nand-flash">Programming a raw NAND flash</h2>
<p>In the following example, we program the <i>at91bootstrap.bin</i>, <i>u-boot.bin</i>, <i>zImage</i>, <i>at91-sam9x60ek.dtb</i> and <i>rootfs.ubi</i> files into the embedded NAND flash of a SAM9X60-EK board:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a nandflash <span class="operator">-</span>c erase
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a nandflash <span class="operator">-</span>c writeboot:at91bootstrap<span class="operator">.</span>bin <span class="operator">-</span>c verifyboot:at91bootstrap<span class="operator">.</span>bin
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a nandflash <span class="operator">-</span>c write:u<span class="operator">-</span>boot<span class="operator">.</span>bin:<span class="number">0x00040000</span> <span class="operator">-</span>c verify:u<span class="operator">-</span>boot<span class="operator">.</span>bin:<span class="number">0x00040000</span>
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a nandflash <span class="operator">-</span>c write:at91<span class="operator">-</span>sam9x60ek<span class="operator">.</span>dtb:<span class="number">0x00180000</span> <span class="operator">-</span>c verify:at91<span class="operator">-</span>sam9x60ek<span class="operator">.</span>dtb:<span class="number">0x00180000</span>
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a nandflash <span class="operator">-</span>c write:zImage:<span class="number">0x00200000</span> <span class="operator">-</span>c verify:zImage:<span class="number">0x00200000</span>
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a nandflash <span class="operator">-</span>c write:rootfs<span class="operator">.</span>ubi:<span class="number">0x00800000</span> <span class="operator">-</span>c verify:rootfs<span class="operator">.</span>ubi:<span class="number">0x00800000</span></pre>
<p><b>If the raw NAND flash is connected to a custom board design, then additional parameters should be passed to the <i>-a nandflash</i> option in above examples.</b></p>
<p>The list of those parameters is given by the command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>a nandflash:help
Syntax: nandflash:<span class="operator">[</span><span class="operator">&lt;</span>ioset<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>bus_width<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>header<span class="operator">&gt;</span><span class="operator">]</span>
Parameters:
    ioset      I<span class="operator">/</span>O set
    bus_width  NAND bus width (<span class="number">8</span><span class="operator">/</span><span class="number">16</span>)
    header     NAND header value
Examples:
    nandflash                 use <span class="keyword">default</span> board settings
    nandflash:<span class="number">2</span>:<span class="number">8</span>:<span class="number">0xc0098da5</span>  use fully custom settings (IOSET2<span class="operator">,</span> <span class="number">8</span><span class="operator">-</span>bit bus<span class="operator">,</span> header is <span class="number">0xc0098da5</span>)
    nandflash<span class="operator">::</span>:<span class="number">0xc0098da5</span>    use <span class="keyword">default</span> board settings but force header to <span class="number">0xc0098da5</span>
For information on NAND header values<span class="operator">,</span> please refer to SAM9X60 datasheet section <span class="string">&quot;11.4.7.1.1 Method 1 (recommended): NAND Flash Specific Header Detection&quot;</span><span class="operator">.</span></pre>
<p>Supported <i>&lt;ioset&gt;</i> for the NAND flash on SAM9X60 devices are listed <a href="qml-samba-device-sam9x60-sam9x60config.html#nand-flash-configuration">here</a>.</p>
<a name="programming-a-qspi-nor-flash"></a>
<h2 id="programming-a-qspi-nor-flash">Programming a QSPI NOR flash</h2>
<p>In the following example, we program the <i>at91bootstrap.bin</i>, <i>u-boot.bin</i>, <i>zImage</i> and <i>at91-sam9x60ek.dtb</i> files into the embedded QSPI NOR flash of the SAM9X60-EK board:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a qspiflash <span class="operator">-</span>c erase
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a qspiflash <span class="operator">-</span>c writeboot:at91bootstrap<span class="operator">.</span>bin <span class="operator">-</span>c verifyboot:at91bootstrap<span class="operator">.</span>bin
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a qspiflash <span class="operator">-</span>c write:u<span class="operator">-</span>boot<span class="operator">.</span>bin:<span class="number">0x00040000</span> <span class="operator">-</span>c verify:u<span class="operator">-</span>boot<span class="operator">.</span>bin:<span class="number">0x00040000</span>
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a qspiflash <span class="operator">-</span>c write:at91<span class="operator">-</span>sam9x60ek<span class="operator">.</span>dtb:<span class="number">0x00180000</span> <span class="operator">-</span>c verify:at91<span class="operator">-</span>sam9x60ek<span class="operator">.</span>dtb:<span class="number">0x00180000</span>
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a qspiflash <span class="operator">-</span>c write:zImage:<span class="number">0x00200000</span> <span class="operator">-</span>c verify:zImage:<span class="number">0x00200000</span></pre>
<p>Most QSPI NOR flash memories are too small to store the Linux root file-system; this should be programmed into another NVM.</p>
<p><b>If the QSPI NOR flash memory is connected to a custom board design, then additional parameters should be passed to the <i>-a qspiflash</i> option in above examples.</b></p>
<p>The list of those parameters is given by the command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>a qspiflash:help
Syntax: qspiflash:<span class="operator">[</span><span class="operator">&lt;</span>instance<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>ioset<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>frequency<span class="operator">&gt;</span><span class="operator">]</span>
Parameters:
    instance   QSPI controller instance
    ioset      QSPI I<span class="operator">/</span>O set
    frequency  QSPI clock frequency in MHz
Examples:
    qspiflash         use <span class="keyword">default</span> board settings
    qspiflash:<span class="number">0</span>:<span class="number">3</span>:<span class="number">66</span>  use fully custom settings (QSPI0<span class="operator">,</span> IOSET3<span class="operator">,</span> <span class="number">66Mhz</span>)
    qspiflash<span class="operator">::</span>:<span class="number">20</span>    use <span class="keyword">default</span> board settings but force frequency to <span class="number">20Mhz</span></pre>
<p>Supported <i>&lt;instance&gt;</i> and <i>&lt;ioset&gt;</i> for QSPI on SAM9X60 devices are listed <a href="qml-samba-device-sam9x60-sam9x60config.html#qspi-flash-configuration">here</a>.</p>
<a name="programming-a-spi-nor-flash"></a>
<h2 id="programming-a-spi-nor-flash">Programming a SPI NOR flash</h2>
<p>In the following example, we program the <i>at91bootstrap.bin</i>, <i>u-boot.bin</i>, <i>zImage</i> and <i>at91-sam9x60ek.dtb</i> files into some SPI NOR flash connected to the FLEXCOM0_SPI of a SAM9X60-based board:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a serialflash:<span class="number">0</span>:<span class="number">1</span>:<span class="number">50</span> <span class="operator">-</span>c erase
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a serialflash:<span class="number">0</span>:<span class="number">1</span>:<span class="number">50</span> <span class="operator">-</span>c writeboot:at91bootstrap<span class="operator">.</span>bin <span class="operator">-</span>c verifyboot:at91bootstrap<span class="operator">.</span>bin
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a serialflash:<span class="number">0</span>:<span class="number">1</span>:<span class="number">50</span> <span class="operator">-</span>c write:u<span class="operator">-</span>boot<span class="operator">.</span>bin:<span class="number">0x00008000</span> <span class="operator">-</span>c verify:u<span class="operator">-</span>boot<span class="operator">.</span>bin:<span class="number">0x00008000</span>
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a serialflash:<span class="number">0</span>:<span class="number">1</span>:<span class="number">50</span> <span class="operator">-</span>c write:at91<span class="operator">-</span>sam9x60ek<span class="operator">.</span>dtb:<span class="number">0x00060000</span> <span class="operator">-</span>c verify:at91<span class="operator">-</span>sam9x60ek<span class="operator">.</span>dtb:<span class="number">0x00060000</span>
$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a serialflash:<span class="number">0</span>:<span class="number">1</span>:<span class="number">50</span> <span class="operator">-</span>c write:zImage:<span class="number">0x0006c000</span> <span class="operator">-</span>c verify:zImage:<span class="number">0x0006c000</span></pre>
<p>SPI NOR flashes are likely to be too small to store the Linux root file-system; this should be programmed into another NVM.</p>
<p><b>If the SPI NOR flash memory is connected to a custom board design, then additional parameters should be passed to the <i>-a serialflash</i> option in above examples.</b></p>
<p>The list of those parameters is given by the command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>a serialflash:help
Syntax: serialflash:<span class="operator">[</span><span class="operator">&lt;</span>instance<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>ioset<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>npcs<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>frequency<span class="operator">&gt;</span><span class="operator">]</span>
Parameters:
    instance   SPI controller instance
    ioset      I<span class="operator">/</span>O set
    npcs       SPI chip select number
    frequency  SPI clock frequency in MHz
Examples:
    serialflash           use <span class="keyword">default</span> board settings
    serialflash:<span class="number">0</span>:<span class="number">1</span>:<span class="number">0</span>:<span class="number">66</span>  use fully custom settings (SPI0<span class="operator">,</span> IOSET1<span class="operator">,</span> NPCS0<span class="operator">,</span> <span class="number">66Mhz</span>)
    serialflash<span class="operator">::</span><span class="operator">::</span><span class="number">20</span>     use <span class="keyword">default</span> board settings but force frequency to <span class="number">20Mhz</span></pre>
<p>Supported <i>&lt;instance&gt;</i>, <i>&lt;ioset&gt;</i> and <i>&lt;npcs&gt;</i> for SPI on SAM9X60 devices are listed <a href="qml-samba-device-sam9x60-sam9x60config.html#spi-serial-flash-configuration">here</a>.</p>
<a name="programming-a-sdcard-or-e-mmc-user-partition"></a>
<h2 id="programming-a-sdcard-or-e-mmc-user-partition">Programming a SDCard or e.MMC user partition</h2>
<p>In the following example, the <i>sdcard.img</i> file is a raw image of a SD Card, hence starting with a Master Boot Record (MBR) containing a valid partition table. The first partition is formatted with a FAT32 file-system, which gathers four files in its root directory:</p>
<ul>
<li>a <i>boot.bin</i> file: the <i>at91bootstrap.bin</i> file renammed into <i>boot.bin</i></li>
<li>a <i>u-boot.bin</i> file: the u-boot binary image, loaded then executed by <i>boot.bin</i></li>
<li>a <i>zImage</i> file: the compressed image of a Linux kernel, loaded then executed by u-boot</li>
<li>a <i>at91-sam9x60ek.dtb</i>: the device-tree binary for the Linux kernel, loaded by u-boot at the same time as the <i>zImage</i> file</li>
</ul>
<p>The second partition is formatted in EXT4 and contains the root file-system used by the Linux kernel</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>t <span class="number">5</span> <span class="operator">-</span>a sdmmc <span class="operator">-</span>c write:sdcard<span class="operator">.</span>img</pre>
<p><b>If the SD Card or e.MMC memory is connected to a customer board design, then additional parameters should be passed to the <i>-a sdmmc</i> option in above examples.</b></p>
<p>The list of those parameters is given by the command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>a sdmmc:help
Syntax: sdmmc:<span class="operator">[</span><span class="operator">&lt;</span>instance<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>ioset<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>partition<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>bus_width<span class="operator">&gt;</span><span class="operator">]</span>:<span class="operator">[</span><span class="operator">&lt;</span>voltages<span class="operator">&gt;</span><span class="operator">]</span>
Parameters:
    instance   SDMMC controller number
    ioset      SDMMC I<span class="operator">/</span>O set
    partition  Partition number (<span class="number">0</span><span class="operator">=</span>user partition<span class="operator">,</span> x<span class="operator">&gt;</span><span class="number">0</span><span class="operator">=</span>boot partition x)
    bus_width  Data bus width (<span class="number">0</span><span class="operator">=</span>controller max<span class="operator">,</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="operator">-</span>bit<span class="operator">,</span> <span class="number">4</span><span class="operator">=</span><span class="number">4</span><span class="operator">-</span>bit<span class="operator">,</span> <span class="number">8</span><span class="operator">=</span><span class="number">8</span><span class="operator">-</span>bit)
    voltages   Supported voltages (bitfield: <span class="number">1</span><span class="operator">=</span><span class="number">1.8V</span><span class="operator">,</span> <span class="number">2</span><span class="operator">=</span><span class="number">3.0V</span><span class="operator">,</span> <span class="number">4</span><span class="operator">=</span><span class="number">3.3V</span>)
Examples:
    sdmmc           use <span class="keyword">default</span> board settings
    sdmmc:<span class="number">0</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="number">8</span>:<span class="number">5</span> use fully custom settings (SDMMC0<span class="operator">,</span> IOSET1<span class="operator">,</span> first boot partition<span class="operator">,</span> <span class="number">8</span><span class="operator">-</span>bit<span class="operator">,</span> <span class="number">1.8V</span><span class="operator">/</span><span class="number">3.3V</span>)
    sdmmc:<span class="number">0</span><span class="operator">::</span><span class="number">1</span>      use <span class="keyword">default</span> board settings but force use of SDMMC0<span class="operator">,</span> first boot partition</pre>
<p>Supported <i>&lt;instance&gt;</i> and <i>&lt;ioset&gt;</i> for SDMMC on SAM9X60 devices are listed <a href="qml-samba-device-sam9x60-sam9x60config.html#sd-mmc-configuration">here</a>.</p>
<a name="secure-boot-mode"></a>
<h2 id="secure-boot-mode">Secure Boot Mode</h2>
<p>First step to benefit from secure boot features of SAM9X60 devices is to enable this secure boot mode as describe in section <a href="sam9x60.html#secure-boot-configuration">Secure Boot Configuration</a>.</p>
<p>Once the <i>Secure Boot Configuration</i> packet has been written, the device must be reset so the ROM code executes its secure SAM-BA monitor:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p serial <span class="operator">-</span>d sam9x60 <span class="operator">-</span>a reset</pre>
<p><b>From this point, the ROM code no longer executes its non-secure SAM-BA monitor but instead runs its secure SAM-BA monitor. Hence, the <a href="port.html#connecting-to-the-non-secure-sam-ba-monitor">serial</a> or <a href="port.html#connecting-through-the-j-link-port">j-link</a> ports cannot be used; the <a href="port.html#connecting-to-the-secure-sam-ba-monitor">secure</a> port must be used instead.</b></p>
<p>Then, another mandatory step is to program the customer key into the device. This customer key is wrapped into a ciphered and signed customer key message.</p>
<p><b>This so called customer key message is actually generated from the <i>640-bit</i> customer key by the <i>secure-sam-ba-cipher.py</i> tool. This tool is distributed under NDA, hence not covered by this documentation.</b></p>
<p>As stated, the customer key message is ciphered to protect the customer key from eavesdropping during device provisioning in factory and is also signed so the customer key message can be authenticated by the ROM code. Only the <i>secure-sam-ba-cipher.py</i> tool with a license provided by Microchip can generate genuine customer key messages.</p>
<p>Assumming the customer key message is packaged inside a <i>customer-key.cip</i> file, programming the customer key into the SAM9X60 device must be done by <i>sam-ba</i> with this command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p secure <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>m write_customer_key:customer<span class="operator">-</span>key<span class="operator">.</span>cip</pre>
<p>At this point and on further resets, the ROM code expects the bootstrap or user application stored into the external NVM to be both <b>ciphered with AES-256-CBC</b> and <b>signed with AES-256-CMAC</b>.</p>
<p>Optionally, the shared key signature algorithm can be replaced by a public key algorithm. More precisely, the AES-256-CMAC signature is replaced by a <b>RSA signature</b> that will be verified by the ROM code at each boot to authenticate the bootstrap or user application.</p>
<p>Indeed, a <b>chain of X.509 <i>version 3</i> certificates in DER format</b> is concatenated to the bootstrap and its RSA signature.</p>
<p>The first certicate in this chain is called the root certificate and must be a <b>self-signed</b> certificate.</p>
<p>Besides, except the root certificate, each certificate in the chain is signed, hence authenticated, by the previous certificate in the chain. So the root certificate, more precisely its public key, is the root of trust since it, directly or indirectly, authenticates all certificates in the chain.</p>
<p>The <i>secure-sam-ba-cipher.py</i> tool can compute a SHA-256 digest of the public key of the root certificate. Like the customer key with the customer key message, this digest is wrapped into a ciphered and signed message called the RSA hash message.</p>
<p><b>The generation of the RSA hash message by <i>secure-sam-ba-ciher.py</i> is not covered by this documentation.</b></p>
<p>Then, assuming the SHA-256 digest of the public key of the X.509 root certificate is packaged inside a <i>root-cert-hash.cip</i> file, programming the digest into the SAM9X60 device must be done by <i>sam-ba</i> with the following command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p secure <span class="operator">-</span>b sam9x60<span class="operator">-</span>ek <span class="operator">-</span>m write_rsa_hash:root<span class="operator">-</span>cert<span class="operator">-</span>hash<span class="operator">.</span>cip</pre>
<p>After that and for each boot, the ROM code still deciphers the bootstrap or the user application with the AES-256-CBC algorithm using the same shared key as before but no longer authenticates it with an AES-256-CMAC signature.</p>
<p>Instead, it computes the SHA-256 digest of the public key of the root certificate with the same algorithm used by the <i>secure-sam-ba-cipher.py</i> tool. Then, the ROM code authenticates the root certificate by comparing the computed digest with the one that has been programmed into the OTPC with the <i>write_rsa_hash</i> command.</p>
<p>If both digests match then the root certificate is authenticated by the ROM code. Next, the ROM code authenticates each X.509 certificate of the chain by verifying its signature with the public key of the previous X.509 certificate in the chain.</p>
<p>Finally, when all X.509 certificates in the chain have been authenticated, the ROM code uses the public key stored into the last certificate of the chain to verify the RSA signature of the bootstrap or user application stored in NVM.</p>
<p><b>To speed-up the boot process, the X.509 certificate chain can be limited to a <i>single</i> X.509 <i>self-signed</i> certificate. In such case, this certificate is both the root certificate and the certificate used to authenticate the bootstrap or user application.</b></p>
<p><b>Both 2048 and 4096-bit RSA signatures are supported by the SAM9X60 devices.</b></p>
<a name="enabling-the-pairing-mode"></a>
<h3 >Enabling the pairing mode</h3>
<p>The <i>pairing mode</i> enhances the secure boot mode with an anti-cloning protection for the target device.</p>
<p>The user can enable this mode with the following built-in monitor command:</p>
<pre class="cpp">$ sam<span class="operator">-</span>ba <span class="operator">-</span>p secure <span class="operator">-</span>d sam9x60 <span class="operator">-</span>m enable_pairing</pre>
</div>
<!-- @@@sam9x60.html -->
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="60%" align="left">Copyright &copy; 2018 Microchip Technology</td>
<td width="40%" align="right"><div align="right">SAM-BA Documentation</div></td>
</tr></table></div></address></body>
</html>
